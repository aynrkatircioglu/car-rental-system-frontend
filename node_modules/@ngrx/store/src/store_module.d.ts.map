{"version":3,"file":"store_module.d.ts","sources":["store_module.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { ModuleWithProviders, OnDestroy, InjectionToken, Injector } from '@angular/core';\nimport { Action, ActionReducer, ActionReducerMap, ActionReducerFactory, StoreFeature, InitialState, MetaReducer, RuntimeChecks } from './models';\nimport { ActionsSubject } from './actions_subject';\nimport { ReducerManager, ReducerObservable } from './reducer_manager';\nimport { ScannedActionsSubject } from './scanned_actions_subject';\nimport { Store } from './store';\nexport declare class StoreRootModule {\n    constructor(actions$: ActionsSubject, reducer$: ReducerObservable, scannedActions$: ScannedActionsSubject, store: Store<any>, guard: any, actionCheck: any);\n}\nexport declare class StoreFeatureModule implements OnDestroy {\n    private features;\n    private featureReducers;\n    private reducerManager;\n    constructor(features: StoreFeature<any, any>[], featureReducers: ActionReducerMap<any>[], reducerManager: ReducerManager, root: StoreRootModule, actionCheck: any);\n    ngOnDestroy(): void;\n}\nexport interface StoreConfig<T, V extends Action = Action> {\n    initialState?: InitialState<T>;\n    reducerFactory?: ActionReducerFactory<T, V>;\n    metaReducers?: MetaReducer<T, V>[];\n}\nexport interface RootStoreConfig<T, V extends Action = Action> extends StoreConfig<T, V> {\n    runtimeChecks?: Partial<RuntimeChecks>;\n}\n/**\n * An object with the name and the reducer for the feature.\n */\nexport interface FeatureSlice<T, V extends Action = Action> {\n    name: string;\n    reducer: ActionReducer<T, V>;\n}\nexport declare class StoreModule {\n    static forRoot<T, V extends Action = Action>(reducers: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>, config?: RootStoreConfig<T, V>): ModuleWithProviders<StoreRootModule>;\n    static forFeature<T, V extends Action = Action>(featureName: string, reducers: ActionReducerMap<T, V> | InjectionToken<ActionReducerMap<T, V>>, config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>): ModuleWithProviders<StoreFeatureModule>;\n    static forFeature<T, V extends Action = Action>(featureName: string, reducer: ActionReducer<T, V> | InjectionToken<ActionReducer<T, V>>, config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>): ModuleWithProviders<StoreFeatureModule>;\n    static forFeature<T, V extends Action = Action>(slice: FeatureSlice<T, V>, config?: StoreConfig<T, V> | InjectionToken<StoreConfig<T, V>>): ModuleWithProviders<StoreFeatureModule>;\n}\nexport declare function _createStoreReducers(injector: Injector, reducers: ActionReducerMap<any, any>): unknown;\nexport declare function _createFeatureStore(injector: Injector, configs: StoreConfig<any, any>[] | InjectionToken<StoreConfig<any, any>>[], featureStores: StoreFeature<any, any>[]): (StoreFeature<any, any> | {\n    key: string;\n    reducerFactory: any;\n    metaReducers: any;\n    initialState: any;\n})[];\nexport declare function _createFeatureReducers(injector: Injector, reducerCollection: ActionReducerMap<any, any>[]): unknown[];\nexport declare function _initialStateFactory(initialState: any): any;\nexport declare function _concatMetaReducers(metaReducers: MetaReducer[], userProvidedMetaReducers: MetaReducer[]): MetaReducer[];\nexport declare function _provideForRootGuard(store: Store<any>): any;\n"]}